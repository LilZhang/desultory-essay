# Java虚拟机的体系结构
- 字长(word): 通常一个单元持有int，returnAddress或reference
- 至少32bit
- 可以为数据设计任意的数据结构
- 每一个用户运行的线程，都是执行引擎的一个实例。

## 类装载器子系统
### 两种类装载器
1. 启动类装载器(BOOTSTRAP)
2. 自定义类装载器

### 装载类时创建class类实例
### 装载顺序
1. 装载：查找.class
2. 连接：验证(正确性)，准备(为类变量分配内存并初始化)以及解析(optional：符号引用转换为直接引用)
3. 初始化：类变量初始值初始化

### 类转载器的namespace表
- 每个类装载器 会维护一张表，表中是每个 类装载器 以及 将该类装载器作为初始类装载器的类 的映射
- 这些表组成namespace

## 内存区
### 方法区
- 每个jvm一个
- 类数据:类型信息，静态变量
- 对方法区的访问是线程安全的
- 如何存储，数据结构皆可自定义(需仔细设计)
- 可在堆中自由分配
- 类可以被卸载，可以被GC
#### 类型信息
1. 该类的全限定名
2. 该类的直接父类的全限定名
3. 该类的接口的全限定名
4. 类 or 接口？
5. 访问修饰符(public, abstract or final)

#### extend类型信息
1. 该类的常量池:直接常量，符号引用常量。数组
2. 字段信息：字段名，类型，修饰符
3. 方法信息1：方法名，返回类型，形参数量及类型，修饰符，方法的字节码
4. 方法信息2：方法的操作数栈，该方法的栈帧中的局部变量区的大小
5. 静态变量(注意编译时常量)
6. 一个到类的ClassLoader的引用
7. 一个到类的Class引用

#### 方法表(可选，对象方法)
- 在方法区内的一组引用，指向方法
- 占用更多内存，轻微提升性能

### 堆
- 每个jvm一个
- 对象实例
- GC可选
- 对象的指针类型
#### 关于对象
1. 对象锁
2. 等待集合(wait set)
3. GC状态标记

#### 关于数组
- 所有具有相同维度和类型的数组拥有同一个class
int[]: `[I`
byte[][][]: `[[[B`
Object[][]: `[[Ljava/lang/Object`


### Java栈
- 每个线程一个，对别的线程不可见
- 调用方法时，压入新的栈帧
- 方法返回或异常时，弹出栈帧

#### 栈帧(stack frame)
##### 局部变量区
- 单位长度为字长的数组(long, double占两项)
- byte, char等都被转成int(如果字长为32位)
- 对象为reference
- 存回堆或方法区中时再转换为原类型
- 字节码使用其索引
- (非静态方法的第一个是对象本身reference)，方法的形参，和局部变量(任意位置)

##### 操作数栈
- 单位长度为字长的数组(long, double占两项)
- 指令通过入栈来存储操作数
- 指令通过出栈来取出操作数
- jvm的工作区
```
iload_0 // 将局部变量中第0个压入操作数栈中
iload_1 // 将局部变量中第1个压入操作数栈中
iadd	// 从操作数栈中弹出两个数，相加，压入操作数栈
istore_2// 从操作数栈中弹出一个数(刚才的结果)，存入局部变量第2个
```

##### 帧数据区
- 拥有该方法的异常表的引用
- 根据异常表处理并派发异常
- 解析常量池
- 接收return值
- 设置PC寄存器指向下一指令
- 调试数据(可选)

### 本地方法栈
- 每个线程一个，对别的线程不可见

### PC寄存器(程序计数器)
- 每个线程一个，对别的线程不可见
- 一个字长
- 一直指向下一条指令(非本地方法)
- undefined(本地方法)

### string_intern 表
- 字面量

## 数据类型
### 基本类型
#### 数值类型
##### 浮点数类型
##### 整数类型
#### boolean
- 在字节码中为int或byte
- 0为false，非0为true

#### retrunAddress

### 引用类型(reference)
#### class类型
#### interface类型
#### array类型

## 指令
- 单字节的操作码
- 0或多个操作数，可以在操作码之后，也可以在当前(类的常量池，局部变量，操作数中)
