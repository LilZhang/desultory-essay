# 垃圾收集
- 销毁对象，释放内存
- 合并堆碎块，腾出连续内存

缺点：性能

## 垃圾收集算法
- 检测出垃圾对象
- 回收垃圾对象的堆空间

如何检测出垃圾对象：
- 建立根对象集合并检查对象到根对象的可触及性
根对象的来源：
1. 栈中局部变量中的对象引用
2. 栈中操作数栈中的对象引用
3. 被加载的类的常量池中的对象引用(比如字符串，包括类名，父类名，接口名，方法名字段名，方法描述符与字段描述符)

区分活动对象和垃圾：
1. 引用计数(早期)
2. 跟踪

## 引用计数收集器(Deprecated)
- 堆中每一个对象有一个引用计数
- 该对象被引用则引用计数 +1
- 指向该对象的引用被修改时引用计数 -1
- 引用计数为0的对象可被回收
- 该对象被回收的时候，其内部指向别的对象的引用的对象，引用计数 -1

缺点：
1. 无法检测互相引用
2. +1 或者 -1 是额外开销

## 跟踪收集器
- 标记并清除

## 压缩收集器
减少堆碎块的方法
1. 压缩
2. 拷贝

- 把活动的对象越过空闲区域滑动到堆的另一端
- 优点：使用对象句柄表减少移动后对象指针更改的开销
- 缺点：每次访问都要经过句柄，性能上有损失

对象A的引用 ->
对象A的引用 -> 对象句柄表 -> 对象本身
对象A的引用 ->

句柄(handle)：智能指针

## 拷贝收集器
- 停止并拷贝
1. 将堆内存一分为二(A/B)
2. 当A的空间达到一个阈值时，将A中的所有对象拷贝至B，紧密排列
3. 当B的空间达到一个阈值时，拷贝至A

- 缺点：需要两倍大小的内存

## 按代收集的收集器
- 大部分对象的生命周期很短
- 某些对象的生命周期非常长

- 将对象按照寿命分组
- 寿命较短的放进 GC 频繁区域
- 在几次 GC 后若该对象依然存活，放进 GC 相对不频繁区域
- 每个区域中的 GC 可以使用“标记-清扫”，也可以使用“停止-拷贝”

## 自适应收集器
- 视情况使用以上的 GC 策略

## 火车算法
- 渐进式垃圾收集：每次回收一部分对象

- 车厢，火车与火车站
- 层级如下
1. 火车站(堆本身)
2. 火车(1, 2, 3 ...)
3. 车厢(1.1, 1.2, 1.3, ..., 2.1, ...)

- 火车算法 start
- 先收集 最小号火车 或 最小号火车的最小号车厢
- 如果 最小号火车 没有火车外部的引用指向它，该火车都可以被 GC，算法 restart
- 如果 最小号火车 有火车外部的引用指向它
1. 关注 其最小号车厢，如果该车厢没有外部引用指向它，则该车厢可被 GC
2. 若有车厢外部引用，找到引用指向对象的 对象网 
3. 若该引用来自别的火车，把 对象网 移动到该火车
4. 若该引用来自同一火车的不同车厢，把 对象网 移动到本火车的最后一节车厢
5. 该车厢可被 GC
6. 下一个车厢
- 火车算法 end

PS：
- 每个车厢与每个火车都有一个 记忆集合，记录了所有指向该车厢(火车)的外部引用
- 对象移动时需要维护该 记忆集合
- 如果某个车厢/火车的记忆集合是空的，那么这个车厢/火车可被 GC

## 终结 (finalize)
- finalize()方法在 GC 时被垃圾收集器调用
- 因为 GC 的时机是不可确定的，所以不能在 finalize() 中有逻辑方法

垃圾收集器 GC 时如下
1. 第一遍扫描：找出需要被 GC 的对象
2. (可选) 直接 销毁掉那些肯定无法复活的对象。
肯定无法复活的对象：被 GC 的对象无法触及的(被 GC 的)对象
3. 执行 finalize() 方法(只能被执行一次)
4. 第二遍扫描：确认那些被 GC 的对象(中间会剔除掉“复活”的对象)
5. GC

ps：复活的对象的 finalize() 不会再被执行

## 对象的可触及性
1.2 之后的引用对象
java.lang.ref.Reference
以及三个子类
SoftReference
WeakReference
PhantomReference

在垃圾收集器视角看，对象有以下状态：
1. (强)可触及: 引用，不可被 GC
2. 可复活: 没有指向该对象的引用，还未执行 finalize() 方法，对象有被复活的可能
3. 不可触及: 没有指向该对象的引用，且以执行了 finalize() 方法，未被复活，可被 GC

1.2之后添加

4. 软可触及: 
- 对象仅通过一个或多个 SoftReference 被引用，GC 时`可能`会被销毁 (在抛出 OutOfMemoryError 之前销毁即可)
- 如果构造时指定了 ReferenceQueue 队列，被销毁(离开软可触及)时该引用对象被传入该队列

5. 弱可触及: 
- 对象仅通过一个或多个 WeakReference 被引用，GC 时`一定`会被销毁
- 如果构造时指定了 ReferenceQueue 队列，被销毁(离开弱可触及)时该引用对象被传入该队列

6. 影子可触及(虚可触及): 
- 对象仅通过一个或多个 PhantomReference 被引用，GC 时`一定`会被销毁
- 创建一个 PhantomReference 时必须要传入 ReferenceQueue
- 而且对象已被 GC 执行过 finalize() 方法，即进入了`影子可触及`阶段
- 同时该引用对象被传入 ReferenceQueue 队列

PS: 三个 Reference 子类的不同之处
1. SoftReference: 
- (只剩下软引用时) 可能被 GC 销毁 (在抛出 OutOfMemoryError 之前销毁即可)
- 构造时 ReferenceQueue 是可选的
- 当准备销毁(离开软引用)时传入 ReferenceQueue
- 包含对象若没有被销毁则能被 get() 出来，否则返回 null

2. WeakReference:
- (只剩下弱引用时) 一定被 GC 销毁
- 构造时 ReferenceQueue 是可选的
- 当准备销毁(离开弱引用)时传入 ReferenceQueue
- 包含对象若没有被销毁则能被 get() 出来，否则返回 null

3. PhantomReference: 
- 创建 PhantomReference 时一定要在构造器中传入 ReferenceQueue，
- 而且对象已被 GC 执行过 finalize() 方法，即进入了`影子可触及`阶段，同时传入 ReferenceQueue。
- 可复活阶段 -> 影子可触及阶段，进入了`影子可触及`阶段则不可再被复活
- 无法再获得对象的强引用，其get()方法一定返回 null 。

用途：
1. SoftReference: 创建内存级缓存
2. WeakReference: 创建规范映射(哈希表，WeakHashMap)
3. PhantomReference: 更加复杂的临终清理方法	// 处理完一定要调用clear()

// PhantomReference 待验证
// 276


































